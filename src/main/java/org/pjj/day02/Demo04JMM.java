package org.pjj.day02;

/**
 *
 * CPU和内存之间访问速度不一样所以需要CPU的三级缓存来应对, CPU处理数据都是从内存读取到CPU高速缓存处理.
 *
 * JVM规范希望定义一种Java内存模型(Java Memory Model, JMM) 来屏蔽掉各种硬件和操作系统的内存访问差异, 使Java程序在各个平台下都能实现一致的内存访问效果.
 *
 * JMM本身是一种抽象的概念并不真实存在, 它仅仅描述的是一组约定或规范, 通过该规范定义了程序中(尤其是多线程)各个变量的读写访问方式和线程对共享变量的写入何时可见.
 *
 * JMM的关键技术点都是围绕多线程的原子性, 可见性, 有序性展开的.
 *
 * 通过JMM来实现线程和主内存之前的抽象关系
 * 屏蔽各个硬件平台和操作系统的内存访问差异以实现Java程序在各个平台下都能达到一致的内存访问效果
 *
 * 可见性: 是指当一个线程修改了某一个共享变量的值, 其他线程是否能够立即知道该变更, JMM规定了所有的变量都存储在主内存中.
 *      系统主内存共享变量数据修改被写入的时机是不确定的, 多线程并发下很可能出现"脏读", 所以每个线程都有自己的工作内存, 线程自己的工作内存中保存了该线程使用到的变量的主内存副本拷贝,
 *      线程对变量的所有操作如读取 赋值等, 都必须要在线程自己的工作内存中进行, 而不能够直接读写主内存中的变量. 不同线程之间也无法直接访问对方工作内存中的变量, 线程间变量值的传递需要通过主内存完成.
 *      "脏读": 主内存中有变量X=0; 线程A先将X=0;拷贝到自己的工作内存中,然后X=1; 线程A将更新后的X值刷新到主内存的时间是不固定的,
 *             假如此时CPU停止调度线程A, 线程B被CPU调度了, 线程B也是要将X+1; 但此时主内存中的X依旧为0, 所以B读取到工作内存中的X=0;处理后刷新到主内存X=1;
 *             此时A线程调度, X=1;写入主内存, 那么此时B线程就脏读了, 最终期待的X=2就会变成X=1;
 * 原子性: 指一个操作是不可打断的, 即多线程环境下, 操作不能被其他线程干扰.
 * 有序性: 对于一个线程的执行代码而言, 我们总是习惯性认为代码的执行总是从上到下, 有序执行. 但是为了提升性能, 编译器和处理器通常会对指令序列进行重新排序. Java规范规定JVM线程内部维持顺序化语义,
 *        即只要程序的最终结果与它顺序化执行的结果相等, 那么指令的执行顺序可以与代码顺序不一致, 此过程就叫指令的重排序
 *        优缺点:
 *          JVM能够根据处理器特性适当的对机器指令进行重排序, 使机器指令能更符合CPU的执行特性, 最大限度的发挥机器性能
 *          但是, 指令重排可以保证串行语义一致, 但没有义务保证多线程间的语义也一致(即可能产生"脏读")
 *        指令重排只能保证单线程下的执行结果一致
 *
 *
 *
 *
 * @author PengJiaJun
 * @Date 2024/06/05 10:21
 */
public class Demo04JMM {
    public static void main(String[] args) {

    }
}
